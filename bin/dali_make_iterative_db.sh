#!/usr/bin/env bash

#------------------------------------------------------------------------------#
# Defining usage and setting inputs
#------------------------------------------------------------------------------#
usage() {
        echo "
        This script takes in a previously generated dali database (consiting of a
        directory with .dat files, and a key converting 4 digit identifiers to original 
        file names) to an iterative db directory structure of the following format:
            ITERATIVE_DB_DIR/
                cluster_file.txt <--- copy of the cluster
                dat_file_key.txt <--- copy of the file key
                reps/ <--- .dat files for all reps
                clusters/
                    cluster_rep_1/ <--- all .dat files for this cluster (including rep)
                    ...
                    cluster_rep_N



        Required params:
        -c --CLUSTER_FILE {path}
            Path to the cluster file. This file can either be generated by foldseek or
            mmseqs (and then likely doesn't have colnames), or can be generated via SAT
            (in which case it likely does have colnames). If there are colnames, there
            must be one called cluster_rep and one called cluster_member. If not, it
            assumes that the first column is cluster_rep and the second column is
            cluster_member.
        -d --DAT_FILE_DIR {path}
            Path to the directory containing the preformated .dat files. It is assumed
            that the .dat file names will be {ID}A.dat, where ID is a 4 digit identifier
            present in the DAT_FILE_KEY. This was generated when running
            dali_format_inputs.sh
        -k --DAT_FILE_KEY {path}
            Path to the key connecting 4 digit identifiers with the original structure
            files. This was generated when running dali_format_inputs.sh
        -o --ITERATIVE_DB_DIR {path}
            Path to the new directory that contains the iterative database.
        "
}

#If less than 4 options are input, show usage and exit script.
if [ $# -le 5 ] ; then
        usage
        exit 1
fi

#Setting input
while getopts c:d:k:o: option ; do
        case "${option}"
        in
                c) CLUSTER_FILE=${OPTARG};;
                d) DAT_FILE_DIR=${OPTARG};;
                k) DAT_FILE_KEY=${OPTARG};;
                o) ITERATIVE_DB_DIR=${OPTARG};;
        esac
done

#------------------------------------------------------------------------------#
# Set defaults and constants
#------------------------------------------------------------------------------#

#------------------------------------------------------------------------------#
# Validate inputs and program availablity
#------------------------------------------------------------------------------#

#------------------------------------------------------------------------------#
# Main
#------------------------------------------------------------------------------#
echo "
$0 inputs:

CLUSTER_FILE: $CLUSTER_FILE
DAT_FILE_DIR: $DAT_FILE_DIR
DAT_FILE_KEY: $DAT_FILE_KEY
ITERATIVE_DB_DIR: $ITERATIVE_DB_DIR
"

#--------------------------------------------------------------------------------------#
# STAGE 1: Parse the cluster file. Will handle situation where there are colnames and
# many columns, or where there are two columns (assumes cluster_rep is col 1 and 
# cluster_member is col 2)
#--------------------------------------------------------------------------------------#

echo "STAGE 1: Parsing cluster file"

# Set up the output directory
mkdir -p $ITERATIVE_DB_DIR/reps
mkdir -p $ITERATIVE_DB_DIR/clusters
cp $CLUSTER_FILE $ITERATIVE_DB_DIR/cluster_file.txt
cp $DAT_FILE_KEY $ITERATIVE_DB_DIR/dat_file_key.txt
echo "" > $ITERATIVE_DB_DIR/seen.txt

# Parse the cluster file. First, check if the cluster file has colnames. If so, use those colnames to find
# the cluster_rep and cluster_member columns
if grep -q '^cluster_' "$CLUSTER_FILE"; then
    # Get the indices of the cluster_rep and cluster_member columns
    cluster_rep_index=$(awk -F'\t' 'NR==1 {for (i=1; i<=NF; i++) if ($i == "cluster_rep") print i; exit}' "$CLUSTER_FILE")
    cluster_member_index=$(awk -F'\t' 'NR==1 {for (i=1; i<=NF; i++) if ($i == "cluster_member") print i; exit}' "$CLUSTER_FILE")

    echo "Found a cluster_rep and cluster_member colname, so using those columns"

    if [ -z "$cluster_rep_index" ] || [ -z "$cluster_member_index" ]; then
        echo "Error: Both cluster_rep and cluster_member columns must be present." >&2
        exit 1
    fi

    # Iterate through the file, printing the values in the identified columns
    awk -F'\t' -v rep="$cluster_rep_index" -v member="$cluster_member_index" 'NR > 1 {print $rep "\t" $member}' "$CLUSTER_FILE" > $ITERATIVE_DB_DIR/cluster_info.txt

# No headers, so assume cluster_rep is in column 1 and cluster_member is in column 2
else
    
    echo "Didn't find colnames. Assuming the first column is cluster_rep, and second column is cluster_member"
    awk -F'\t' '{print $1 "\t" $2}' "$CLUSTER_FILE" > $ITERATIVE_DB_DIR/cluster_info.txt
fi

#--------------------------------------------------------------------------------------#
# STAGE 2: 
# 1) Use the database_key (of format FILE,,ID, where ID is a 4 digit identifier and the 
#    .dat file is named ${ID}A.dat) to find the .dat file for the cluster_rep and 
#    cluster members
# 2) Make a directory format as follows:
#    ITERATIVE_DB_DIR/
#       reps/ <--- .dat files for all reps
#       clusters/
#           cluster_rep_1/ <--- all .dat files for this cluster, including the rep
#           ...
#           cluster_rep_N
#--------------------------------------------------------------------------------------#
echo "STAGE 2: Making dbs."


# Keep track of progress
TOTAL=$(wc -l $CLUSTER_FILE | awk '{print $1}')
COUNT=0

cat $ITERATIVE_DB_DIR/cluster_info.txt | while read LINE ; do 

    CLUSTER_REP=$(echo $LINE | awk '{print $1}')
    CLUSTER_MEMBER=$(echo $LINE | awk '{print $2}')

    # remove .pdb if it is present
    CLUSTER_REP=${CLUSTER_REP/.pdb/}
    CLUSTER_MEMBER=${CLUSTER_MEMBER/.pdb/}

    # Check if we've seen the cluster_rep yet. If not, copy the cluster_rep to the 
    # cluster rep db and make a directory for it's members.
    if ! grep -q "$CLUSTER_REP" "$ITERATIVE_DB_DIR/seen.txt"; then
        
        mkdir $ITERATIVE_DB_DIR/clusters/$CLUSTER_REP

        # Using the key, find the 4 digit identifier (and thus the .dat file) for the 
        # cluster rep
        REP_ID=$(grep $CLUSTER_REP $DAT_FILE_KEY | awk -F",," '{print $2}')
        REP_DAT_FILE=$DAT_FILE_DIR/${REP_ID}A.dat

        # Copy the rep to both the cluster dir and the dir with all of the reps
        cp $REP_DAT_FILE $ITERATIVE_DB_DIR/clusters/$CLUSTER_REP
        cp $REP_DAT_FILE $ITERATIVE_DB_DIR/reps
        
        # Record that we've seen this cluster rep
        echo "$CLUSTER_REP" >> $ITERATIVE_DB_DIR/seen.txt
    fi

    # Using the key, find the 4 digit identifier (and thus the .dat file) for the 
    # cluster member. Then, copy it over
    MEMBER_ID=$(grep $CLUSTER_MEMBER $DAT_FILE_KEY | awk -F",," '{print $2}')
    MEMBER_DAT_FILE=$DAT_FILE_DIR/${MEMBER_ID}A.dat
    cp $MEMBER_DAT_FILE $ITERATIVE_DB_DIR/clusters/$CLUSTER_REP

    COUNT=$(($COUNT+1))
    echo "${COUNT}/$TOTAL"

done && rm $ITERATIVE_DB_DIR/seen.txt