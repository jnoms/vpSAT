#!/usr/bin/env bash

#------------------------------------------------------------------------------#
# Defining usage and setting inputs
#------------------------------------------------------------------------------#
usage() {
        echo "
        This script runs colabfold locally using the colabfold_batch command. 
        You must have colabfold installed! It is highly recommended that the
        input to this file is an a3m alignment generated by mmseqs2, althuogh 
        you may also input a fasta containing a single sequence. If a fasta is
        input, colabfold will query the mmseqs online server for alignment. This
        script uses gpu unless the -u switch is specified.

        Required params:
        -i --INFILE {a3m or fasta}
            Input a3m alignment file or fasta file containing a single sequence.
            Note that the file MUST end in .a3m or .fasta so that colabfold
            knows the input file type.
        -d --OUT_DIR {path}
            The name of the output directory. This will contain many output
            files including multiple structural models, png's of plddt, a copy
            of the a3m input file, etc. Notably, the best pdb model will match
            the pattern *rank_1*.pdb, but all models will be present.

        Optional params:
        -o --OUTFILE {pdb}
            If specified, will create a copy of the best-model pdb file (e.g.
            the file that matches the path OUT_DIR/*rank_1*.pdb) at the
            specified path. Note - if there are multiple models that are rank_1 
            (sometimes multiple have the same pLDDT), the first one will be picked.
        -s --SCORE_FILE (json)
            If specified, the scores json file of the best match will be output to this
            path. 
        -n --NUM_RECYCLES {int} [DEFAULT: 3]
            Number of recycles for colabfold when generating structures.
        -m --NUM_MODELS {int} [DEFAULT: 3]
            Number of colabfold models to run. Options are {1, 2, 3, 4, 5}.
        -1 --STOP_AT_SCORE {int} [DEFAULT: 70]
            If a model has at least this pLDDT, it will stop computing structures and 
            use that model as the top.
        -2 --STOP_AT_SCORE_BELOW {int} [DEFAULT: 40]
            If a model has a pLDDT below this number, it is probably fruitless to
            continue computing structures so stop computing and use the top model
            up to now.
        -c --CUSTOM_TEMPLATES_DIR {dir} [DEFAULT: '']
            If you're running colabfold completely locally, you don't want it to
            try to contact the templates server. Instead, provide a path to a directory
            that contains .cif structure files (must be .cif, not .cif.gz and not 
            .pdb). These structures will be searched for templates. This can be slow for
            e.g. a local copy of the pdb.
        -t --USE_TEMPLATES
            Boolean switch.
            If specified, will query the templates server (or use
            --CUSTOM_TEMPLATES_DIR) to find templates for structure prediction.
        -u --USE_CPU
            Boolean switch.
            If specified, will add the --cpu flag and run via cpu. Not
            recomended, as it will take ages to run.
        -a --USER_AMBER
            Boolean switch.
            If specified, will use the --amber switch for structure relaxation.
            This isn't the default because it can fail sometimes (probably
            dependent on resources).
        "
}

#If less than 2 options are input, show usage and exit script.
if [ $# -le 3 ] ; then
        usage
        exit 1
fi

# Boolean flag defaults
USE_CPU=false
USER_AMBER=false
USE_TEMPLATES=false

#Setting input
while getopts i:d:o:s:n:1:2:m:c:tua option ; do
        case "${option}"
        in
                i) INFILE=${OPTARG};;
                d) OUT_DIR=${OPTARG};;
                o) OUTFILE=${OPTARG};;
                s) SCORE_FILE=${OPTARG};;
                1) STOP_AT_SCORE=${OPTARG};;
                2) STOP_AT_SCORE_BELOW=${OPTARG};;
                n) NUM_RECYCLES=${OPTARG};;
                m) NUM_MODELS=${OPTARG};;
                c) CUSTOM_TEMPLATES_DIR=${OPTARG};;
                t) USE_TEMPLATES=true;;
                u) USE_CPU=true;;
                a) USER_AMBER=true;;
        esac
done

#------------------------------------------------------------------------------#
# Set defaults and constants
#------------------------------------------------------------------------------#
# Defaults
NUM_RECYCLES=${NUM_RECYCLES:-3}
OUTFILE=${OUTFILE:-""}
SCORE_FILE=${SCORE_FILE:-""}
STOP_AT_SCORE=${STOP_AT_SCORE:-70}
STOP_AT_SCORE_BELOW=${STOP_AT_SCORE_BELOW:-40}
NUM_MODELS=${NUM_MODELS:-3}
CUSTOM_TEMPLATES_DIR=${CUSTOM_TEMPLATES_DIR:-""}

if [[ $CUSTOM_TEMPLATES_DIR == "" ]] ; then
    CUSTOM_TEMPLATES_SETTING=""
else
    if $USE_TEMPLATES ; then
        CUSTOM_TEMPLATES_SETTING="--custom-template-path ${CUSTOM_TEMPLATES_DIR}"
    else
        echo "You've specified --CUSTOM_TEMPLATES_DIR but aren't using the"
        echo " --USE_TEMPLATES switch."
        exit 1
    fi
fi

if $USE_TEMPLATES ; then
    USE_TEMPLATES_SETTINGS="--templates"
else
    USE_TEMPLATES_SETTINGS=""
fi

if $USER_AMBER ; then
    AMBER_SETTING="--amber"
else
    AMBER_SETTING=""
fi


#------------------------------------------------------------------------------#
# Validate inputs and program availablity
#------------------------------------------------------------------------------#

# Make sure input file ends in .a3m or .fasta. If it's a fasta, make sure it
# only has one sequence
if [[ $INFILE == *.a3m ]] ; then
    :
elif [[ $INFILE == *.fasta ]] ; then
    if (( $(grep -c "^>" $INFILE) > 1 )) ; then 
        echo "Input fasta file must contain only one sequence."
        echo "(grep -c "^>" $INFILE) sequences are detected."
        exit 1 
    fi
else 
    echo "Input file does not end in .a3m or .fasta!!"
    exit 1
fi

# Make sure all input files exist
if [ ! -f $INFILE ] ; then
    echo "Input file, $INFILE, not detected."
    exit 1
fi

# Make sure required programs are available
if ! command -v colabfold_batch ; then
    echo "colabfold_batch not detected!"
    exit 1
fi


#------------------------------------------------------------------------------#
# Main
#------------------------------------------------------------------------------#
echo "
$0 inputs:

INFILE: $INFILE
OUT_DIR: $OUT_DIR
OUTFILE: $OUTFILE
NUM_RECYCLES: $NUM_RECYCLES
STOP_AT_SCORE: $STOP_AT_SCORE
STOP_AT_SCORE_BELOW: $STOP_AT_SCORE_BELOW
NUM_MODELS: $NUM_MODELS
CUSTOM_TEMPLATES_DIR: $CUSTOM_TEMPLATES_DIR
USE_TEMPLATES: $USE_TEMPLATES
USE_CPU: $USE_CPU
USER_AMBER: $USER_AMBER
"

echo "$0: Started at $(date)"

# Make output directory if necessary
mkdir -p $OUT_DIR

# Run colabfold
colabfold_batch \
    --num-recycle $NUM_RECYCLES \
    --use-gpu-relax \
    --num-models $NUM_MODELS \
    $USE_TEMPLATES_SETTINGS \
    $CUSTOM_TEMPLATES_SETTING \
    $AMBER_SETTING \
    $INFILE \
    $OUT_DIR 

    # --stop-at-score $STOP_AT_SCORE \
    # --stop-at-score-below $STOP_AT_SCORE_BELOW \

# If OUTFILE is specified, copy the best model to the outfile
# Depending on the colabfold version in the system, the ranks are labled rank_N or rank_00N
if [[ $OUTFILE != "" ]] ; then
    cp $(ls ${OUT_DIR}/*rank_1*.pdb | head -n1) $OUTFILE || cp $(ls ${OUT_DIR}/*rank_001*.pdb | head -n1) $OUTFILE
fi

if [[ $SCORE_FILE != "" ]] ; then
    cp $(ls ${OUT_DIR}/*rank_1*.json | head -n1) $SCORE_FILE || cp $(ls ${OUT_DIR}/*rank_001*.json | head -n1) $SCORE_FILE
fi

echo "ended at $(date)"
